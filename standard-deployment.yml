parameters:
- name: defaultBranchName
  type: string
  default: 'master'
# determine what set of templates will be used for the pipeline
- name: deployType 
  type: string
  default: 'null'
  values:
  - 'null'
  - ADO
  - ReactApp
  - LambdaService
# use a Docker container to run Validate and Build stages
# expects a named image, otherwise uses your repo's devcontainer (default)
- name: useContainerImage 
  type: string
  default: true
# execute Terraform from the repo's '/terraform' directory
# pass a valid terraform version number to force use of that version
- name: useTerraform
  type: string
  default: true
# make Terraform outputs available to the BuildSources and DeployArtifacts jobs
- name: useTFOutputs
  type: boolean
  default: false

variables:
- template: helpers/select-environment.yml
  parameters:
    defaultBranchName: ${{ parameters.defaultBranchName }}
    ${{ if eq(parameters.deployType, 'ADO') }}:
      skipDEV: true
      skipUAT: true

- ${{ if ne(parameters.useTerraform, false) }}:
  - template: Terraform/environment.yml
    parameters:
      AWS_ACCOUNT: $(AWS_ACCOUNT)  
      AWS_REGION: $(AWS_REGION)
      CICD_ROLE_NAME: $(CICD_ROLE_NAME)
      ENVIRONMENT_NAME: $(ENVIRONMENT_NAME)
      repoName: $(Build.Repository.Name)
      sourcesDirectory: $(Build.SourcesDirectory)

stages:
- stage: Validate
  jobs:
  - ${{ if ne(parameters.useTerraform, false) }}:
    - template: Terraform/validate.yml
      parameters:
        useTFOutputs: ${{ parameters.useTFOutputs }}
        ${{ if eq(parameters.deployType, 'ADO') }}:
          env:
            AZDO_PERSONAL_ACCESS_TOKEN: '$(AZDO_PERSONAL_ACCESS_TOKEN)'

  - ${{ if and(ne(parameters.deployType, 'null'), ne(parameters.useContainerImage, false)) }}:
    # Identify the docker image for later stages
    - job: GetContainerImage
      displayName: Container Image
      steps:
      - template: helpers/container-get-image.yml
        parameters:
          useContainerImage: ${{ parameters.useContainerImage }}

  - ${{ if and(ne(parameters.deployType, 'null'), ne(parameters.useContainerImage, false)) }}:  
    - template: helpers/container-job.yml
      parameters: 
        job: ValidateSources
        displayName: Source Code
        dependsOn: GetContainerImage
        condition: in(variables.ENVIRONMENT_NAME, 'DEV', 'QA')
        steps:
        - template: ${{ parameters.deployType }}/validate.yml

- stage: Deploy
  dependsOn:
    - Validate
  variables:
    HAS_TERRAFORM_APPLY: $[ stageDependencies.Validate.Terraform.outputs['TerraformCondition.isRequired'] ]
    ${{ if in(parameters.deployType, 'ReactApp') }}:
      FORCE_TERRAFORM_APPLY: true 
  jobs:
  - ${{ if and(ne(parameters.deployType, 'null'), ne(parameters.useContainerImage, false)) }}:
    - template: helpers/container-job.yml
      parameters: 
        job: BuildSources
        displayName: Build ${{ parameters.deployType }}
        ${{ if eq(parameters.useTFOutputs, true) }}:
          dependsOn: Terraform
        steps:
        - template: ${{ parameters.deployType }}/build.yml
          parameters:
            useTFOutputs: ${{ parameters.useTFOutputs }} 

  - ${{ if ne(parameters.useTerraform, false) }}:
    - template: Terraform/deploy.yml
      parameters:
        condition: and(succeeded(), or(eq(variables.FORCE_TERRAFORM_APPLY, true), ne(variables.HAS_TERRAFORM_APPLY, false)))
        deployType: ${{ parameters.deployType }}
        useTerraform: ${{ parameters.useTerraform }}
        ${{ if in(parameters.deployType, 'LambdaService') }}:
          preDeploySteps: 
          - template: ${{ parameters.deployType }}/deploy.yml

  - ${{ if in(parameters.deployType, 'ReactApp') }}:
    - deployment: DeployArtifacts
      displayName: Deploy ${{ parameters.deployType }}
      dependsOn: 
        - BuildSources
        - Terraform
      condition: and(succeeded('BuildSources'), or(succeeded('Terraform'), eq(variables.HAS_TERRAFORM_APPLY, false)))
      environment: $(ENVIRONMENT_NAME)
      strategy:
        runOnce:
          deploy:  
            steps:
            - template: ${{ parameters.deployType }}/deploy.yml
              parameters:
                useTFOutputs: ${{ parameters.useTFOutputs }}

- stage: Update
  jobs:
  - deployment: NotifyClients
    displayName: Notify Clients
    environment: $(ENVIRONMENT_NAME)
    strategy:
      runOnce:
        deploy:  
          steps:
          - checkout: none
          - script: |
              gql='mutation($input: CreateVersionInput!){ createVersion(input: $input){ createdAt } }'
              payload=$(jq -ernc \
                --arg gql "$gql" \
                --arg buildId "$BUILD_BUILDID" \
                --arg buildReason "$BUILD_REASON" \
                --arg environmentName "$ENVIRONMENT_NAME" \
                --arg initiatedBy "$BUILD_REQUESTEDFOREMAIL" \
                --arg isScheduled "$SYSTEM_ISSCHEDULED" \
                --arg pipelineName "$BUILD_DEFINITIONNAME" \
                --arg projectName "$SYSTEM_TEAMPROJECT" \
                --arg sourceBranch "$BUILD_SOURCEBRANCH" \
                --arg VersionNumber "$VersionNumber" \
                '{
                  query: $gql, 
                  variables: {
                    input: {
                      buildId: $buildId,
                      buildReason: $buildReason,
                      environmentName: $environmentName,
                      initiatedBy: $initiatedBy,
                      isScheduled: $isScheduled,
                      pipelineName: $pipelineName,
                      projectName: $projectName,
                      sourceBranch: $sourceBranch,
                      versionNumber: $VersionNumber
                    }
                  }
                }')
              echo "##vso[task.setvariable variable=output;isOutput=true]${payload}"
            name: Payload
            displayName: Generate Payload
            env:
              VersionNumber: $(Build.BuildNumber) #TODO: replace with semantic version number
          - task: LambdaInvokeFunction@1
            name: UpdateAPI
            inputs:
              awsCredentials: $(AWS_SERVICE_CONNECTOR)
              regionName: $(AWS_REGION)
              functionName: testCICDUpdate
              payload: $(Payload.output)
              outputVariable: updateResult
          - script: echo $(updateResult)
            displayName: Print Result